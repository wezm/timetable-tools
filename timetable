#!/usr/bin/env ruby

require 'nokogiri'
require 'csv'
require 'cairo'
require 'optparse'

PADDING = 5

config = {
  :tables => 2,
  :histograms => false,
  :gap => 10,
}
OptionParser.new do |o|
  o.banner = "Usage: timetable timetable.xml"

  o.separator ""
  o.separator "Converts the input XML (produced by pdftohtml) into CSV."
  o.separator "Output file is derived from input basename."
  o.separator ""

  o.on("-i", "--histograms", "Output row and column histograms") do |i|
    config[:histograms] = i
  end

  o.on("-g", "--gap", "The minumum gap between text to define a new row or column, default #{config[:gap]}") do |g|
    config[:gap] = g
  end

  o.on("-t", "--tables TABLES", Integer, "The number of tables per page, default #{config[:tables]}") do |t|
    config[:tables] = t
  end

  o.on_tail("-h", "--help", "Show this message") do
    puts o
    exit
  end
end.parse!

if ARGV.size < 1
  $stderr.puts "Usage: timetable timetable.xml"
  exit 2
end

xml_file = ARGV[0]

def draw_histogram(freq, output_path)
  # Determine the dimensions of the canvas
  width = freq.keys.max + (2 * PADDING)
  height = freq.values.max + (2 * PADDING)

  surface = Cairo::ImageSurface.new(Cairo::Format::RGB24, width, height)
  c = Cairo::Context.new(surface)

  # Draw the white background
  c.set_source_color(Cairo::Color::WHITE)
  c.rectangle(0,0,width,height)
  c.fill

  c.set_source_color(Cairo::Color::RED)
  freq.each do |x, y|
    next unless y > 0
    c.move_to(x + PADDING, height - PADDING)
    c.line_to(x + PADDING, height - y - PADDING)
    c.stroke
  end

  # Write out the image
  surface.write_to_png(output_path)
end

tables = Array.new(config[:tables]) { |i| { :rows => Hash.new(0), :columns => Hash.new(0) } }

f = File.open(xml_file)
xml = Nokogiri::XML.parse(f)
f.close()

page_number = 1

page = xml.at_css("page[number='#{page_number}']")
page_width = page['width'].to_i
page_height = page['height'].to_i

xml.css("page[number='#{page_number}'] text").each do |text|
  left = text['left'].to_i
  top  = text['top'].to_i

  # partition into tables
  table = tables[top / (page_height / config[:tables])]

  table[:columns][left] += 1
  table[:rows][top] += 1
end

def gap(freq)
  gaps = [0]
  freq.keys.sort.each_cons(2) do |left, right|
    if right - left > config[:gap]
      finish = left + ((right - left) / 2)
      gaps << finish
    end
  end

  gaps
end

def group(key, bucket_defs)
  bucket = nil
  bucket_defs.each_with_index do |boundary, i|
    if key > boundary
      bucket = i
    else
      break
    end
  end
  bucket
end

config[:tables].times do |table|
  [:rows, :columns].each do |dimension|
    if config[:histograms]
      histogram_file = File.basename(xml_file, File.extname(xml_file)) + "-histogram-#{dimension}-table-#{table + 1}.png"
      draw_histogram(tables[table][dimension], histogram_file)
    end
    tables[table]["#{dimension}_boundaries".to_sym] = gap(tables[table][dimension])
  end

  timetable = Array.new(tables[table][:rows_boundaries].count) { |i| Array.new(tables[table][:columns_boundaries].count) }

  # Partition the elements
  xml.css("page[number='#{page_number}'] text").each do |text|
    left = text['left'].to_i
    top  = text['top'].to_i

    row = group(top,  tables[table][:rows_boundaries])
    col = group(left, tables[table][:columns_boundaries])
    timetable[row][col] = text.inner_text.strip
  end

  csv_file = File.basename(xml_file, File.extname(xml_file)) + "-table-#{table + 1}.csv"
  CSV.open(csv_file, "w") do |csv|
    timetable.each do |row|
      csv << row
    end
  end
end
